### 스레드 관리

## 프로세스(Process)와 스레드(Thread)

- 프로세스는 자원을 할당 받고 자원을 제어하여 일을 한다.
- 스레드는 실(~)이고, 프로세스에 제어만 분리해 놓은 것이다.
- 하나의 프로세스 안에 여러개의 스레드(제어)가 있을 수 있다.

- 스레드

  - resources : 코드, 전역 데이터, heap
  - process 제어 : sp(stack pointer), pc(program counter), 상태, 지역 데이터, 스택
  - 프로세스가 제어 영역을 이용하여 resources를 관리한다.
  - process 제어(스레드)는 여러개 존재 할 수 있다.
  - resources는 공유한다.
  - light weight process 이다.
  - 프로세서 활용의 기본 단위이다. 하나의 스레드가 하나의 cpu를 사용한다.
  - 구성요소
    - thread id
    - register set(pc, sp)
    - stack
  - 제어 요소 외 코드, 데이터, 및 자원들은 프로세스 내 다른 스레들과 공유
  - 전통적 프로세스 = 단일 스레드 프로세스이다.

- 스레드의 장점

  - 사용자 응답성
    - 일부 스레드의 처리가 지연되어도, 다른 스레드는 작업을 계속 처리 가능, cpu의 한 개의 코어는 보통 한개의 스레드를 처리힌다.
  - 자원 공유
    - 자원을 공유해서 효율성 증가(커널의 개입을 피할 수 있음)
    - 두 프로세스가 자원을 공유해서 사용하려면 컨텍스트 스위칭이 발생
  - 경제성
    - 프로세스의 생성, context switch에 비해 효율적
  - 멀티 프로세서 활용

    - 병령처리를 통해 성능 향상

  - 스레드와 프로세스의 context switching 차이
    - 스레드 context switching은 코드, 힙, 전역 데이터는 그대로 두고 제어 부분(thread id, register set(pc, sp), stack) 부분만 바꿔주면 된다.
    - 프로세스 context switching은 메모리 address, page tables, kernel resources, caches in the processor의 switching을 동반한다.

- 스레드(Thread)의 구현

  - 사용자 수준 스레드
  - 커널 수준 스레드

  - 사용자 수준 스레드
    - 사용자 영역의 스레드 라이브러리로 구현됨
    - 스레드의 생성, 스케쥴링등
    - 프로세스가 실행 되면 커널이 메인 스레드를 하나 만들어 준다.
    - 라이브러리를 통해 여러개의 스레드를 만들면, 라이브러리가 스레드 제어 블록(TCB)를 만들어 스레드를 관리한다.(메모리에서)
    - 커널은 라이브러리에 의해 만들어진 스레드의 존재를 모르기 때문에, 생성 및 관리 부하가 적고 유연한 관리가 가능하다.
    - 만약 하나의 라이브러리 스레드가 I/O 때문에 블록 상태가 되면, 프로세스가 블록 되고 결국은 모든 라이브러리 스레드가 대기하는 상태가 된다.
  - 커널 수준 스레드
    - OS(Kernel)가 직접 관리 수행
    - 커널 영역에서 스레드의 생성, 관리 수행
    - 프로세스 실행 중 스레드가 생성되면 스레드 제어 블록(TCB)를 커널 영역에 만들고 커널이 직접 관리한다. 커널이 스레드의 존재를 안다.
    - CONTEXT SWITCHING등 부하(Overhead)가 큼 -> 프로세스 수준의 context switching 보다는 가볍다.
    - 커널이 각 스레드를 개별적으로 관리한다.
    - 프로세스 내 스레드들이 병행 수행 가능하다. 하나의 스레드가 block 되어도, 다른 스레드는 계속 작업 수행한다.
